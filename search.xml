<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LJH线段树</title>
    <url>/2020/02/17/LJH%E7%BA%BF%E6%AE%B5%E6%A0%91/</url>
    <content><![CDATA[<p><a href="http://codeforces.com/blog/entry/18051" target="_blank" rel="noopener">参考（白嫖）文献</a></p>
<p>原作者是英文的来着，我是高中时候写最短路的时候看见的qaq，当时自己改了一下，拿来当堆用，跑了<a href="https://www.luogu.com.cn/problem/P3371" target="_blank" rel="noopener">luogu最短路板子</a>的rank1qaq。说明这个还是很顶的。</p>
<!--readmore-->

<hr>
<h3 id="1-单元素修改的线段树"><a href="#1-单元素修改的线段树" class="headerlink" title="1.单元素修改的线段树"></a>1.单元素修改的线段树</h3><ul>
<li><p>我们这里考虑两种操作</p>
<ul>
<li><ol>
<li>修改数组中的一个元素</li>
<li>求某个区间的元素总和</li>
</ol>
</li>
<li><p>这里我们先假设数组的元素个数为2的幂，这里以16为例，最下面一行（叶子节点）是我们的数组<br><img src="/2020/02/17/LJH%E7%BA%BF%E6%AE%B5%E6%A0%91/1.png" alt="n = 16 时的树"></p>
<ul>
<li><p>修改操作的话就直接修改然后向上维护就行<br>求和操作：<br>   举个栗子，我们需要求<strong>[3,11)</strong>的和，只需要对19、5、12、26节点求和即可</p>
</li>
<li><pre><code>#include&lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e6 + 5;

int n, t[N &lt;&lt; 1];

//build the tree
void build() {
   for(int i = n - 1;i &gt; 0; --i) t[i] = t[i&lt;&lt;1] + t[i&lt;&lt;1|1];
}

//set val at position p
void modify(int p,int val) {
   for(t[p += n] = val; p &gt; 1; p &gt;&gt;= 1) t[p&gt;&gt;1] = t[p] + t[p^1];
}

//sum on interval [l, r)
int query(int l,int r) {
   int res = 0;
   for(l += n, r += n; l &lt; r;l &gt;&gt;= 1, r &gt;&gt;= 1) {
       if(l&amp;1) res += t[l++];
       if(r&amp;1) res += t[--r];
   }
   return res;
}

int main(){
   scanf(&quot;%d&quot;,&amp;n);
   for(int i = 0; i &lt; n; ++i) scanf(&quot;%d&quot;, t + n + i);
   build();modify(0,1);
   printf(&quot;%d\n&quot;,query(3,11));
   return 0;
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">   - 十分优美。</span><br><span class="line">  </span><br><span class="line">   - 接下来解释一下这样做为什么有效而且高效~</span><br><span class="line">  </span><br><span class="line">      - 从图片中您可以注意到，叶子存储在以*n*开头的连续节点中，索引为*i的*元素对应于索引为*i* +  *n*的节点。因此，我们可以将初始值直接读入它们所属的树中。</span><br><span class="line">     - 在执行任何查询之前，我们需要构建树，这很简单，并且需要*O*（*n*）时间。由于父级的索引始终小于子级，因此我们仅按降序处理所有内部节点。如果您对位操作感到困惑，则build（）的代码等效于`t[i] = t[2*i] + t[2*i+1]`。</span><br><span class="line">     - 修改元素也非常简单，并且花费的时间与树的高度成正比，即*O*（*log*（*n*））。我们只需要更新给定节点的父节点中的值即可。因此，我们知道了节点*p的*父节点为*p* / 2或`p&gt;&gt;1`，便向上走树，这意味着相同。`p^1`将2 *  *i*变成2 *  *i* + 1，反之亦然，因此它表示*p*的父级的第二个子级。</span><br><span class="line">     - 求和也可以在*O*（*log*（*n*））时间内进行。为了更好地理解它的逻辑，您可以遍历区间[ 3、11]的示例，并验证结果是否完全由节点19、26、12和5中的值组成（按此顺序）。</span><br><span class="line">  </span><br><span class="line">  - 总体思路如下。如果*l*（左间隔边界）是奇数（等于`l&amp;1`），则*l*是其父级的右子级。然后我们的间隔包括节点*l，*但不包括它的父节点。因此，我们通过设置*l* =（*l* + 1）/ 2来添加`t[l]`并移动到*l*的父母的右边。如果*l*是偶数，则它是左孩子，并且该间隔也包括它的父对象（除非右边界干扰了），所以我们通过设置*l* =  *l* / 2来移至它。类似的论点也适用于右边界。边界遇见后我们便停止。</span><br><span class="line">  </span><br><span class="line">    无需递归，也无需进行其他计算（例如找到间隔的中间部分），我们只需遍历所需的所有节点，因此非常高效。</span><br><span class="line"></span><br><span class="line">- 前面我们的讨论完全基于任意大小的数组，但是事实上这个代码适用于任意大小的数组，解释会复杂的多，但是我们先来看看它带给我们的好处</span><br><span class="line">  - 1. 线段树只使用了2 * n 内存，而不是像传统线段树一样使用4 * n；</span><br><span class="line">    2. 数组元素从 索引n 开始连续存储</span><br><span class="line">    3. 所有操作都十分高效而且容易编写</span><br><span class="line">  -  您可以跳过下一部分，仅测试代码以检查其是否正确。但是对于那些对某种解释感兴趣的人，这是*n* = 13的树的样子 </span><br><span class="line">   ![n = 13 时的树](LJH线段树/2.png)</span><br><span class="line">  -  它实际上不再是一棵树，而是一组完美的二叉树：具有根2和高度4，根7和高度2，根12和高度2，根13和高度1。用于**查询**操作，因此存储在其中的内容无关紧要。叶子似乎出现在不同的高度，但是可以通过在节点13之前切割树并将树的右部分向左移动来固定叶子。我相信，就我们执行的操作而言，所产生的结构对于较大的完美二叉树的一部分可以证明是同构的，这就是为什么我们获得正确结果的原因。 </span><br><span class="line">  -  在这里，我们不进行证明，让我们来看一下间隔为[0，7）的示例。我们有*l* = 13，  *r* = 20，`l&amp;1 =&gt; add t[13]`边界变为*l* = 7，  *r* = 10。同样`l&amp;1 =&gt; add t[7]`，边界变为*l* = 4，  *r* = 5，并且突然节点处于相同的高度。现在`r&amp;1 =&gt; add t[4 = --r]`，边界变为*l* = 2，  *r* = 2，到此结束。 </span><br><span class="line"></span><br><span class="line">### 2.区间修改，单元素访问</span><br><span class="line"></span><br><span class="line">- 这里我们考虑两种操作</span><br><span class="line"></span><br><span class="line">  - 1. 向某区间中的所有元素添加一个值</span><br><span class="line">    2. 求某个位置的元素值</span><br><span class="line"></span><br><span class="line">  - 在这种情况下，我们需要修改`Modify`和`query`函数</span><br></pre></td></tr></table></figure>
void modify(int l, int r, int value) {
 for (l += n, r += n; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) {
   if (l&amp;1) t[l++] += value;
   if (r&amp;1) t[--r] += value;
 }
}

int query(int p) {
 int res = 0;
 for (p += n; p &gt; 0; p &gt;&gt;= 1) res += t[p];
 return res;
}
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-   很像是之前的`query`函数与`Modify`函数互换了qaq，这里等于打了tag</span><br><span class="line">   </span><br><span class="line">-  如果在修改后的某个时刻需要检查数组中的所有元素，则可以使用以下代码将所有修改推到叶子上。之后，我们可以遍历以索引*n*开头的元素。这样，我们将复杂度从*O*（*nlog*（*n*））降低到*O*（*n*），类似于使用*build*而不是进行n次修改。</span><br><span class="line"></span><br><span class="line">   ``` </span><br><span class="line">   void push() &#123;</span><br><span class="line">     for (int i = 1; i &lt; n; ++i) &#123;</span><br><span class="line">       t[i&lt;&lt;1] += t[i];</span><br><span class="line">       t[i&lt;&lt;1|1] += t[i];</span><br><span class="line">       t[i] = 0;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></code></pre></li>
</ul>
</li>
<li><p>但是请注意，以上代码仅在单个元素的修改顺序不影响结果的情况下才有效。例如，分配不满足此条件。有关更多信息，请参阅关于延迟传播的部分。 （就是lazy标记啦）</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-Non-commutative-combiner-functions"><a href="#3-Non-commutative-combiner-functions" class="headerlink" title="3. Non-commutative combiner functions"></a>3. Non-commutative combiner functions</h3><ul>
<li>我们可以很容易就把上面的代码改成最大堆 or 最小堆， 这也是为啥我拿线段树当堆用</li>
</ul>
<h3 id="4-延迟传播"><a href="#4-延迟传播" class="headerlink" title="4. 延迟传播"></a>4. 延迟传播</h3><ul>
<li><p>和传统线段树类似，通过lazy标记来实现范围查询与范围修改</p>
</li>
<li><p>我们需要更多的变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int h = sizeof(int) * 8 - __builtin_clz(n);</span><br><span class="line">int d[N];</span><br></pre></td></tr></table></figure>
</li>
<li><p><em>h</em>是树的高度， <em>n中</em>的最高有效位。<code>d[i]</code>是一个延迟的操作，在必要时可以传播到节点 <em>i</em>的子级（这在示例中应该更加清楚）。数组大小仅<code>N</code>是因为我们不必为叶子存储此信息-它们没有任何子对象。这导致我们总共使用 3 *  <em>n</em>内存。 </p>
</li>
<li><p><strong>区间修改，区间最大值</strong></p>
<ul>
<li>这可能是最简单的情况。下面的代码远不是通用的，也不是最有效的，但这是一个很好的起点。 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void apply(int p, int val)&#123;</span><br><span class="line">    t[p] += val;</span><br><span class="line">    if(p &lt; n) d[p] += val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void build(int p) &#123;</span><br><span class="line">    while(p &gt; 1) p &gt;&gt;= 1, t[p] = max(t[p &lt;&lt; 1], t[p &lt;&lt; 1 | 1]) + d[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void push(int p) &#123;</span><br><span class="line">    for(int s = h; s &gt; 0; --s) &#123;</span><br><span class="line">        int i = p &gt;&gt; s;</span><br><span class="line">        if(d[i] != 0) &#123;</span><br><span class="line">            apply(i&lt;&lt;1  , d[i]);</span><br><span class="line">            apply(i&lt;&lt;1|1, d[i]);</span><br><span class="line">            d[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void inc(int l, int r, int val) &#123;</span><br><span class="line">    l += n, r += n;</span><br><span class="line">    int l0 = l, r0 = r;</span><br><span class="line">    for(; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123;</span><br><span class="line">        if(l&amp;1) apply(l++, val);</span><br><span class="line">        if(r&amp;1) apply(--r, val);</span><br><span class="line">    &#125;</span><br><span class="line">    build(l0);build(r0 - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int query(int l, int r) &#123;</span><br><span class="line">    l += n, r += n;</span><br><span class="line">    push(l);push(r - 1);</span><br><span class="line">    int res = -2e9;</span><br><span class="line">    for(; l &lt; r; l &gt;&gt;= 1, r &gt;&gt;= 1) &#123;</span><br><span class="line">        if(l&amp;1) res = max(res, t[l++]);</span><br><span class="line">        if(r&amp;1) res = max(res, t[--r]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>是代码嗷</category>
      </categories>
      <tags>
        <tag>LJH线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>优先队列</title>
    <url>/2020/02/16/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>qaq，我优先队列经常记不住，自己又懒得写堆，每次要用都得baidu一下，害。今天索性就好好复习一下。</p>
<!--readmore-->

<hr>
<h4 id="1-基本类型"><a href="#1-基本类型" class="headerlink" title="1. 基本类型"></a>1. 基本类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//升序队列，即小顶堆</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; q;</span><br><span class="line">//降序队列，即大顶堆</span><br><span class="line">priority_queue&lt;int,vector&lt;int&gt;,less&lt;int&gt; &gt; q;</span><br><span class="line">//     这里一定要有空格，不然就变成右移运算符了↑</span><br><span class="line"></span><br><span class="line">//对于基础类型，还有一种写法，默认大顶堆</span><br><span class="line">priority_queue&lt;int&gt; q;</span><br></pre></td></tr></table></figure>

<h4 id="2-使用Pair"><a href="#2-使用Pair" class="headerlink" title="2.使用Pair"></a>2.使用Pair</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//pair的比较，先比较第一个后比较第二个</span><br><span class="line">//(2,5) &gt; (1,3) &gt; (1,2)</span><br><span class="line">priority_queue&lt;pair&lt;int,int&gt; &gt; q;</span><br></pre></td></tr></table></figure>

<p>为了直观，我贴个代码好了qaq。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 5;</span><br><span class="line"></span><br><span class="line">typedef pair&lt;int,int&gt; pii;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt; &gt; q;</span><br><span class="line"></span><br><span class="line">int n, x, y;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i = 1;i &lt;= n;++i) scanf(&quot;%d%d&quot;,&amp;x,&amp;y),q.push(make_pair(x,y));</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        printf(&quot;(%d,%d) &quot;,q.top().first,q.top().second);q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1 2</span><br><span class="line">1 3</span><br><span class="line">2 5</span><br><span class="line">2 4</span><br><span class="line">5 6</span><br><span class="line">(1,2) (1,3) (2,4) (2,5) (5,6)</span><br></pre></td></tr></table></figure>

<h3 id="3-自定义类型"><a href="#3-自定义类型" class="headerlink" title="3. 自定义类型"></a>3. 自定义类型</h3><p>自定义类型只要定义了比较运算或者重载了小于号就可以了~</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e6 + 5;</span><br><span class="line"></span><br><span class="line">//在结构体内重载运算符 &lt;</span><br><span class="line">// 大顶堆</span><br><span class="line">struct edge&#123;</span><br><span class="line">    int u, v, w;</span><br><span class="line"></span><br><span class="line">    bool operator&lt;(const edge&amp; a) const&#123;</span><br><span class="line">        return w &lt; a.w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//在结构体外重写仿函数</span><br><span class="line">// 大顶堆</span><br><span class="line">struct cmp&#123;</span><br><span class="line">    bool operator() (edge a, edge b)&#123;</span><br><span class="line">        return a.w &lt; b.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//结构体内重载运算符</span><br><span class="line">priority_queue&lt;edge&gt; q;</span><br><span class="line"></span><br><span class="line">//结构体外重写仿函数</span><br><span class="line">priority_queue&lt;edge, vector&lt;edge&gt;, cmp&gt; q;</span><br><span class="line"></span><br><span class="line">int n, x, y, z;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i = 1;i &lt;= n;++i) scanf(&quot;%d%d%d&quot;,&amp;x,&amp;y,&amp;z),q.push(edge&#123;x,y,z&#125;);</span><br><span class="line">    while(!q.empty())&#123;</span><br><span class="line">        printf(&quot;(%d,%d,%d)\n&quot;,q.top().u,q.top().v,q.top().w);q.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输入输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1 2 3</span><br><span class="line">2 3 4</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">2 3 1</span><br><span class="line">2 3 4</span><br><span class="line">(7,8,9)</span><br><span class="line">(4,5,6)</span><br><span class="line">(2,3,4)</span><br><span class="line">(2,3,4)</span><br><span class="line">(1,2,3)</span><br><span class="line">(2,3,1)</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>是代码嗷</category>
      </categories>
      <tags>
        <tag>优先队列</tag>
      </tags>
  </entry>
  <entry>
    <title>合并果子</title>
    <url>/2020/02/16/%E5%90%88%E5%B9%B6%E6%9E%9C%E5%AD%90/</url>
    <content><![CDATA[<p>是在补<strong>合并果子</strong>来着，但是也是回顾一下很多差不多（<del>去掉</del>）忘记的知识点~ </p>
<p>的确是这样。qaq。</p>
<p>题目是luogu的P1090嗷</p>
<!--readmore-->

<hr>
<h4 id="1-原题"><a href="#1-原题" class="headerlink" title="1. 原题"></a>1. 原题</h4><div class="note info">
            <h3 id="luogu-P1090-合并果子"><a href="#luogu-P1090-合并果子" class="headerlink" title="luogu P1090 - 合并果子"></a><a href="https://www.luogu.com.cn/problem/P1090" target="_blank" rel="noopener">luogu P1090 - 合并果子</a></h3>
          </div>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include&lt;queue&gt;</span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#include&lt;cstring&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">const int N = 1e4 + 5;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt; &gt; q;// 小顶堆</span><br><span class="line"></span><br><span class="line">int n, x, ans;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(int i = 1;i &lt;= n;++i) scanf(&quot;%d&quot;,&amp;x),q.push(x);</span><br><span class="line">    while(q.size() != 1)&#123;</span><br><span class="line">        x = q.top();q.pop();x += q.top();q.pop();</span><br><span class="line">        ans += x;q.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d\n&quot;, ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过合并果子，复习了一哈优先队列~</p>
<p>觉得好像没做啥，那就复习一下堆好了~</p>
<hr>
<p>我回来了，网上找了一圈，没有很优美的代码qaq，而且都说没有必要手打堆（除非是P选手？抑或是情怀党</p>
<p>为了效率，完全可以用pb_ds库里面各种奇奇怪怪的堆（逃，记得之前为了luogu P 3371 的效率花式用各种数据结构，结果还是zkw线段树最快，qaq，现在是ljh堆最快，逃</p>
<p>想到了自己的线段树，我或许可以复习一下线段树qaq</p>
<hr>
<p>2.16 鸽于此，本来还想写一下用合并果子的O(N)实现来着（钻了数据范围的空子)，下次一定。咕咕咕~</p>
<h3 id><a href="#" class="headerlink" title></a></h3>]]></content>
      <categories>
        <category>是代码嗷</category>
      </categories>
      <tags>
        <tag>堆</tag>
        <tag>桶排</tag>
        <tag>霍夫曼</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2020/02/11/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>觉得之前做的事情算是没有必要的，毕竟我不是在写教程，我只是想做一下笔记，以防之后自己忘记了</p>
<p>再说教程<a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732792973664" target="_blank" rel="noopener">廖雪峰</a>写的很好了哈，所以我只想稍微对命令做一点总结。QAQ</p>
<a id="more"></a>

<hr>
<ul>
<li><p>学到的一点命令（Git 无关）</p>
<ul>
<li><pre><code>$ mkdir learngit // 在当前目录创建名为&quot;learngit&quot; 的文件夹
$ cd learngit    // 进入&quot;learngit&quot;文件夹
$ pwd            // 显示当前目录
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  - </span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">- 创建版本库</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
$ git init // 通过git init 命令将目录变成 Git 
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git add readme.txt // 将已有文件添加到暂存区
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit -m &quot;wrote a readme file&quot; // 将全部暂存区文件提交至仓库， -m &quot;xxxx&quot; 是说明
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &gt; 添加文件到Git仓库，分两步</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; 1. 使用命令`git add &lt;flie&gt; `，注意，可反复多次使用，添加多个文件；</span><br><span class="line">    &gt;</span><br><span class="line">    &gt; 2. 使用命令`git commit -m &lt;message&gt;  `，完成</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 基本用法</span><br><span class="line"></span><br><span class="line">  ![basic - usage](Git学习笔记/basic-usage.png)</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
$ git add files //把当前文件放入暂存区域。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit   //给暂存区域生成快照并提交。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git reset -- files  //用来撤销最后一次git add files，你也可以用git reset 撤销所有暂存区域文件。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git checkout -- files 把文件从暂存区域复制到工作目录，用来丢弃本地修改。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  ![basic - usage - 2](Git学习笔记/basic-usage-2.png)</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit -a //相当于运行 git add 把所有当前目录下的文件加入暂存区域再运行。git commit.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit files //进行一次包含最后一次提交加上工作目录中文件快照的提交。并且文件被添加到暂存区域。
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git checkout HEAD -- files //回滚到复制最后一次提交。</code></pre></li>
</ul>
</li>
</ul>
<hr>
<p>草（一种植物，为什么有人帮我把笔记也做好了啊！！！做的真好，我可以偷懒了，唔。</p>
<p>就这样了，本文鸽了。看笔记请查阅<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">原文</a>。写的真好，草（一种植物</p>
<hr>
<p>虽然好像有部分内容未涉及。qaq。</p>
]]></content>
      <categories>
        <category>是学习嗷</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>记一件删除快捷方式小箭头引发的惨案</title>
    <url>/2020/02/11/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%88%A0%E9%99%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%AE%AD%E5%A4%B4%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/</url>
    <content><![CDATA[<p>不知道你们怎么看，反正我是觉得快捷方式左下角的小箭头十分不美观（强迫症患者实锤</p>
<!--readmore-->

<hr>
<p>然后，昨天就动手删除了，果不其然，任务栏上固定的文件资源管理器又失效了TAT（为什么说又，因为之前删过一次，也失效了，但是不知道为啥小箭头又出现了qaq</p>
<p>在尝试过网上各种乱七八糟的方法后，我的注册表也变得乱七八糟qaq，但是丝毫没有效果，还是这个亚子</p>
<p><img src="/2020/02/11/%E8%AE%B0%E4%B8%80%E4%BB%B6%E5%88%A0%E9%99%A4%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E5%B0%8F%E7%AE%AD%E5%A4%B4%E5%BC%95%E5%8F%91%E7%9A%84%E6%83%A8%E6%A1%88/1.png" alt></p>
<p>于是我 更换了搜索引擎，换成<strong>必应</strong>之后第一次尝试好像就好了。。真棒嗷</p>
<p>看的是<a href="https://zhidao.baidu.com/question/1052783200548895179.html" target="_blank" rel="noopener">百度知道的第一个回答</a>。</p>
<p>就是把下面的代码加进注册表就好</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Folder\shell\explore\command]</span><br><span class="line">&quot;DelegateExecute&quot;=&quot;&#123;11dbb47c-a525-400b-9e80-a54615a090c0&#125;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Folder\shell\opennewprocess\command]</span><br><span class="line">&quot;DelegateExecute&quot;=&quot;&#123;11dbb47c-a525-400b-9e80-a54615a090c0&#125;&quot;</span><br><span class="line"></span><br><span class="line">[HKEY_CLASSES_ROOT\Folder\shell\opennewwindow\command]</span><br><span class="line">&quot;DelegateExecute&quot;=&quot;&#123;11dbb47c-a525-400b-9e80-a54615a090c0&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>Orz，差不多就这样了。</p>
]]></content>
      <categories>
        <category>是生活嗷</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 插入图片的问题</title>
    <url>/2020/02/10/hexo-%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p> 因为之前的年终总结也有插入图片，但是好像并不能显示出来嗷~</p>
<p>然后就上网查了一下解决方法。</p>
<a id="more"></a>

<hr>
<h4 id="1-第一种：使用图床嗷"><a href="#1-第一种：使用图床嗷" class="headerlink" title="1. 第一种：使用图床嗷"></a>1. 第一种：使用图床嗷</h4><p>​        怎么说，推荐的是七牛云，当时也鼓捣了一会，后面好像做忘了？然后就不管了，感兴趣的同学可以自己去康康哈~</p>
<h4 id="2-第二种：使用hexo自带插件"><a href="#2-第二种：使用hexo自带插件" class="headerlink" title="2.第二种：使用hexo自带插件"></a>2.第二种：使用hexo自带插件</h4><p>​        这个可真是一个大坑。。</p>
<p>​        网上的教程千篇一律，而且几乎都是错的（我本地无效QAQ</p>
<p>​        然后，使劲去找解决方案嘛，现在终于弄好了</p>
<p>​        推荐查看<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">hexo 本地图片不显示</a></p>
<p>​        我实在是懒得写嗷</p>
<p>​        如果安装错了的话，可以这样卸载掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>​        差不多就酱了哈，又解决了一个问题</p>
<hr>
<p>现在就是这个空格问题真的烦人嗷，还是解决不了捏</p>
<p>目前情况就是<strong>Tab</strong>与<strong>空格</strong>好像都无效，但是复制过来的内容不受影响。TAT</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>Test</title>
    <url>/2020/02/08/test/</url>
    <content><![CDATA[<p>​        害，一直以来Tab键好像就出了点问题，稍微试试嗷。也顺便试试一些乱七八糟的东西，qaq</p>
<a id="more"></a>

<hr>
<h4 id="Tab"><a href="#Tab" class="headerlink" title="Tab :"></a>Tab :</h4><p>​    我是一个Tab</p>
<p>​        我是两个Tab</p>
<p>（完全没有区别好嘛TAT）</p>
<p>​    我是四个空格</p>
<p>　　我是TAT</p>
<p>​        我是八个空格</p>
<hr>
<h4 id="居中引用："><a href="#居中引用：" class="headerlink" title="居中引用："></a>居中引用：</h4><blockquote class="blockquote-center"><p>人生不相见，动如参与商。</p>
</blockquote>

<hr>
<h4 id="超大图片"><a href="#超大图片" class="headerlink" title="超大图片"></a>超大图片</h4><p>​    emmm,没想好放啥图片，那就放个头像好了。</p>
<p><img src="/2020/02/08/test/1.jpg" alt="害"></p>
<img src="/2020/02/08/test/1.jpg" class="full-image">

<p>啥诶，各种奇奇怪怪好嘛。</p>
<hr>
<h4 id="Bootstrap-Callout："><a href="#Bootstrap-Callout：" class="headerlink" title="Bootstrap Callout："></a>Bootstrap Callout：</h4><div class="note default">
            <p>Content_default (md partial supported) </p>
          </div>

<div class="note primary">
            <p>Content_primary (md partial supported) </p>
          </div>

<div class="note success">
            <p>Content_success (md partial supported) </p>
          </div>

<div class="note info">
            <p>Content_info (md partial supported) 题目链接专用好了qaq</p>
          </div>

<div class="note warning">
            <p>Content_warning (md partial supported) </p>
          </div>

<div class="note danger">
            <p>Content_danger (md partial supported) </p>
          </div>

]]></content>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>日记</title>
    <url>/2020/02/08/%E6%97%A5%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><hr>
<p>为啥突然想起来写日记捏~</p>
<p>嗯。。</p>
<p>一是一向以来文字能力就不是很好。也想稍微锻炼一下自己。（或许记的会是流水账？？</p>
<p>二是从放假以来就过的迷迷糊糊的，也是稍微写点东西记录生活，也是稍微激励一下自己不要一直颓废。略略略</p>
<p>就酱吧。</p>
<a id="more"></a>]]></content>
      <categories>
        <category>是生活嗷</category>
      </categories>
      <tags>
        <tag>是日记嗷</tag>
      </tags>
  </entry>
  <entry>
    <title>2019年终总结</title>
    <url>/2020/02/08/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="2019年终总结"><a href="#2019年终总结" class="headerlink" title="2019年终总结"></a>2019年终总结</h3><p>一年时光又从我的指尖悄然流过，不得不说，恍如隔世，前半年是水生火热，后半年是柳暗花明。</p>
<p>这么说 也许有些过分，但是，对我而言，大学生活所具有的自由现在就是我的氧气。</p>
<a id="more"></a>

<p>这一年没有想像中的那么完满，之前觉得天都会塌下来的事情现在看来也不过那样，不过是换个地方继续生活。</p>
<p>很抱歉啊，没有活成你想要的样子。但是啊，我真的有一直在好好努力。</p>
<p>2019年的自己，say goodbye。</p>
<p>2020年的我，会是更好的自己。</p>
<p>这一年，虽说不够完满，但是已经足够令我满意。</p>
<p>最后，感谢一切关心过我帮助过我的人们，我不习惯点名，但是，我有念着你们的好。嗯，还有，感谢武汉</p>
<p>大学送的录取通知书，让我，与她，与你们，与更好的自己相遇~</p>
<p>我不知道该说些什么，我只是，这一刻，很想很想你。</p>
<p><img src="/2020/02/08/2019%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/1.jpg" alt="害"></p>
]]></content>
      <categories>
        <category>是生活嗷</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>武松</title>
    <url>/2020/01/29/%E6%AD%A6%E6%9D%BE/</url>
    <content><![CDATA[<blockquote class="blockquote-center"><p>摘自《死人经》（冰临神下著）相关一  武松</p>
</blockquote>

<a id="more"></a>

<p>　　 初更时分，“武行者立在岭头上看时，见月从东边上来，照得岭上草木生辉。”</p>
<p>　　《水浒传》当中，这一场景最令我印象深刻，它是一幅充满象征意义的画面，正是以蜈蚣岭为界，武松的人生前后截然不同，他在一个全然陌生的地方，抛掉从前的幻想与原则，成为一名真正的江湖人。</p>
<p>　　水浒诸好汉的形象与性格，大都出场即定型，从头至尾极少变化，唯有武松是个另类，有一个清晰可辨的转变过程，依稀就是一名从小痴迷蛊惑仔电影、对江湖充满热情的青年，守在江湖的门口却不被允许进入，最终发现一切皆虚，唯有手中的刀最为真实，于是将规矩踩在脚下，反而一步迈进了江湖的中心。</p>
<p>　　三次杀人，解释了一切。</p>
<p>　　初时的武松，一心想成为江湖人，可惜递上的却是一份不光彩的履历：他在家乡打伤了人，以为对方死了，结果那人只是昏迷，过后又活过来。</p>
<p>　　武松随口将这件事说给宋江，想必也随口说给了柴进庄上诸人，全然不知这会给自己的名声带来多大的负面影响，柴进以孟尝君自居，所救助的人越是犯法横行，越显得他仗义疏财，杀人的武松与打架的武松，在他眼里是截然不同的两类人。</p>
<p>　　柴大官人的眼光，就是江湖的眼光。</p>
<p>　　声名显赫者如宋江，初出江湖时尚且要将“杀阎婆惜”一事挂在嘴上，直到江州题了反诗，才算有了更光辉的履历，武松误以为自己杀人，怎能不惹人耻笑？</p>
<p>　　柴进对武松先恭后倨，其实与武二郎的“气性刚”无关，他的庄上惯常接纳亡命之徒，武松绝不是最刚烈者，他输在事迹上，比如投名状，别人送上一颗乃至数颗人头，他却只有将人打昏的一拳，差别相当于会捕猎的狼与发疯咬人的狗。</p>
<p>　　“身躯凛凛，相貌堂堂”的武松对“狼”的江湖一心向望。</p>
<p>　　跟所有江湖人一样，他喜欢吹牛，在众口相传的世界里，这是必须的基本素质之一，好比现在的网络名人，哪怕花钱买，也得存几个能逗人会心一笑的段子。</p>
<p>　　他也知道自己的事迹不佳，所以初见宋江时才会说“只一拳打得那厮昏沉”，想象武二郎当时的样子，脑子里得存着三五好友酒桌比斗的场景，“只一拳”就是他最值得炫耀的本事了，在正常的世界里，这足以使他鹤立鸡群，在江湖，不过是笑柄。</p>
<p>　　宋江比柴进有眼力，看出武松是真正的江湖人，是石头包裹的璞玉，他的热情接纳、十里相送，在这块石头上凿出了第一个孔眼。</p>
<p>　　武松希望融入江湖，但他也是普通人，遵守社会中的一般准则，所以，他的第一次杀人是为兄报仇。</p>
<p>　　同样是杀“淫嫂”的情节，武松的手段与另一位梁山好汉石秀几乎处处相反。</p>
<p>　　武松要证据，这证据是给街坊、给官方、给天下人看的，所以他要仔细探访，甚至一件小事也要人证物证俱全。石秀也要证据，却只是给义兄杨雄一个人看，潘公待他不薄，石秀从未想过要给这老儿一个交待。</p>
<p>　　武松要当众杀人，遍邀左邻右舍，不准不来，然后他记下口供，拔出刀来，“只一剜”，取出潘金莲心肝五脏，祭奠亡兄，然后又一刀割下妇人头，接着又去酒楼杀西门庆。石秀与杨雄将潘巧云与丫环骗到荒山野岭，暗中杀人，并无他人得见。</p>
<p>　　武松杀过人自来见官，石秀、杨雄望后山逃亡，径投梁山泊。</p>
<p>　　此时的武松，与真正的江湖人天差地别，最重要的一条就是他守法。</p>
<p>　　武松守法，而且知恩图报，知县让他当都头，他不能甩手就走，石秀对潘公毫无交待，更不在乎官府的看法，潘巧云死后，地方官只能猜测真相，就连不愿落草的杨志，丢了生辰纲也是甩手就跑，没回去向恩主说个明白。</p>
<p>　　武松主动提供了一切证据，事情在这里发生了有趣的转变，即使放在现在，仍有极深的教育意义。</p>
<p>　　武松的拿出的证据是“错误”的。</p>
<p>　　法律中的正义与普通人的想象有很大区别，武松执行了普通人的正义，杀死淫嫂与奸夫，除了西门庆的家人，满县称赞，但是在法律上，即使有一百个理由，主动杀人也是重罪。</p>
<p>　　知县是个懂法的人，与手下小吏将武松送上的供词稍作修改，于是主动杀人变成了争执中不慎杀人，带有正当防卫的性质。</p>
<p>　　守法却不会利用法律，向望江湖却不懂江湖规则，这时的武松就是如此尴尬，他第一次杀人，得来的名声仍然不如此前的打虎，十字坡张青听得姓名，问的是“莫不是景阳岗打虎的武都头？”</p>
<p>　　因此，发配孟州的路上，张青、孙二娘劝武松落草是不可能成功的，武松尚且记挂着两名押解公人的好处，这样的人如何混得了江湖？</p>
<p>　　在这种情况下，武松与张青喝酒时的场面不免有些喜感，书中写“两个又说些江湖上好汉的勾当，却是杀人放火的事”，关键是武松一样不沾，他杀嫂也不是江湖手段，却与真正的江湖人张青说得兴高采烈。</p>
<p>　　两个公人听到这些话，吓得呆住了，只是下拜，武松劝慰道：“我等江湖上好汉们说话，你休要吃惊，我们并不肯害为善的人。”</p>
<p>　　哈哈，每次读到这一段文字，我都忍不住要笑，此时的武松何其形象、何其真实、何其可爱？</p>
<p>　　也算在江湖上混迹过的人，武松还是显得那么稚嫩，张青刚刚说过孙二娘不分青红皂白地下迷药杀人，武松却说“我们并不肯害为善的人”，夫妻二人听在耳中该是何等心情？</p>
<p>　　武松终于能与江湖人搭上话了，但他还是未得其门而入。</p>
<p>　　孟州牢营里，施恩拉拢武松这一段文字，必须与柴进庄上宋江的行为对比着观看，才有大意思。</p>
<p>　　论江湖手段，施恩也是个愣头青，手段笨拙得像是初经云雨的青涩少年。</p>
<p>　　送饭人已经将事情从头到尾备说一遍，连主人姓施名恩人称“金眼彪”都透露了，末了却说“小管营吩咐小人道：‘休要说知备细’。”施恩之猴急心态跃然纸上。</p>
<p>　　回过头再看宋江，喝酒、赠银、送行，无一刻倦怠、无一字相求，却将武松的心牢牢拢住。</p>
<p>　　施恩是管营公子，放在如今算是不大不小的官二代，没多少江湖经验，做人不说，尤其不会说话，先是让仆人透露实情，接着又故作矜持，求人帮忙，却说让他“将息三五个月”，这话在武松听来，无异于怀疑自己的本事，当然很不顺耳。</p>
<p>　　等到施恩同意武松举石墩证明实力，两人的交情也就止于此了，金眼彪只是一个小混混，成不了宋江，甚至当不得张青。</p>
<p>　　书中着力描写施恩之愣，最明显也是最有趣的对比发生父子之间。</p>
<p>　　说起快活林的生意，施恩极为直白，“小弟一者倚仗随身本事，二者捉着营里有八九十个弃命囚徒，去那里开着一个酒肉店，都分与众店家和赌坊、兑坊里，但有过路**之人到那里时，先要来参见小弟，然后许她去趁食……月终也有三二百两银子寻觅。”</p>
<p>　　这一番话格调极低，尽是**、银子的事，那一句“营里弃命囚徒”，在武松听来必定更为刺耳，原来施恩根本没将他当成江湖好汉看待。</p>
<p>　　都说官场也是江湖，老管营一开口就与儿子有云泥之别，说起同样的生意，老管营道：“愚男原在快活林中做些买卖，非为贪财好利，实是壮观孟州，增添豪杰气象。”</p>
<p>　　“壮观孟州增添豪杰气象”，将一件肮脏生意说得如此大气磅礴，老管营证明，官场才是更高级的江湖，宋江当小吏无所作为，在江湖中却混得风生水起，就是因为他那一套笼络人心的本事，放在官场里实在不值一提。</p>
<p>　　读懂这两番话的区别，差不多也就能看透一多半的日报文章了。</p>
<p>　　武松要去醉打蒋门神，这一回他没有杀人，其实连打人也不是重点，他隐约明白了江湖中名声的重要，他要扬名，所以一路喝酒，一路无所谓，非要将施恩等人镇住不可。</p>
<p>　　武松还是没有领悟行走江湖的窍门，在他身上，缺少亡命之徒的气质，与石秀、李奎这些人相比，他太谨慎了，勉强达到鲁智深的水平：先要挑事，然后再打。</p>
<p>　　官场与江湖，虽有共通之处，手段却截然不同，这很正常，强健者觉得力量最重要，聪明人觉得智慧最重要，人人都选自己的长处当标准，江湖人有刀剑，为官者掌法律，发生冲突的时候，当然各自要用最擅长的手段。</p>
<p>　　阳谷知县利用法律救了武松一命，张都监则要用同样的方法杀他。</p>
<p>　　武松不懂官场，就跟他不懂江湖一样，张都监将武松留在身边，大概是怕老管营看出破绽吧。</p>
<p>　　武松的“不懂”并非愚钝，他是个聪明人，也是个极有自制力的人，后者才是他处境不上不下的根源。</p>
<p>　　江湖中有太多不能宣之于口的规则，说出来就显得势利，会坏了交情，武松怀着理想，以至于无法看破这层窗户纸，他也没交到真正的知己，宋江、张青夫妇都不可能对他坦诚相待。</p>
<p>　　张都监的家宴上，武松生怕酒醉之后失了礼节，不敢痛饮，早早拜退，结果落入陷阱。</p>
<p>　　事发之后，施恩“慌忙入城和父亲商议”，果然还是老管营立刻看清真相，“眼见得是张团练替蒋门神报仇，买嘱张都监，却设出这条计策陷害武松。”</p>
<p>　　在老管营的指点下，武松勉强保住性命，他的梦想是江湖，虽然当过都头，对官场却只是远观，从未涉足，第一次接触，头破血流的是他。</p>
<p>　　官场固然黑暗，江湖也绝非光明，武松的梦想即将轰然坍塌。</p>
<p>　　官场的手段是法律，但是当法律不能完全达成目标时，张都监等人打算破坏规则，也要借助于刀剑。</p>
<p>　　江湖的手段是义气，施恩却只能做到一半，他不是鲁智深，没有那个本事，也没有那个胆量，做不到有始有终，更做不出野猪林飞铲救人的事迹。</p>
<p>　　武松只有一个人。</p>
<p>　　在飞云浦，武松杀死两名意欲害他的公差，开始他第二次杀人，他“提着朴刀，踌躇半晌，一个念头，竟奔回孟州城里来。”</p>
<p>　　一个念头，就是一个念头，武松在不自觉的情况下变成了江湖人。</p>
<p>　　他不想再要证据，那是官场的手段，与江湖何干？他不想当众杀人、沿途喝酒，那不过是虚名，在险恶的江湖里毫无意义。</p>
<p>　　一个念头，武松捅破了心里的那层窗户纸，即使如此，他仍然保留了几分从前的性格：自制而谨慎。</p>
<p>　　他永远也不会像李奎那样杀进仇人家里。</p>
<p>　　血溅鸳鸯楼一段写得极为细致，连更换衣裳、上墙跳墙、刀放何处这样的小事都不遗漏，通观《水浒传》，再无一处如此详尽。</p>
<p>　　为兄报仇时，武松只杀淫嫂与奸夫，连王婆都留给官府，十字坡酒店里，他坚决拒绝伤害押解公人，快活林中，他拳拳皆有分寸。</p>
<p>　　飞云浦的一个念头，让武松变了一个人，他杀马夫、杀女使、杀养娘玉兰、杀张都监夫人，等等，不问善恶、不多一言，他终于用上了江湖手段，画蛇添足的是，他在墙壁上血字书写：杀人者打虎武松也。</p>
<p>　　杀人留名后来成为许多江湖小说的桥段，其实在《水浒传》这部书里，留名绝非标准行为，武松此一举动显露出的更多是稚嫩，而不是凶狠。</p>
<p>　　多年前有一部专拍武松的电视剧，里面放大了养娘玉兰的情节，武松对她颇为心动，为了情节合理，只好安排玉兰自杀，而不是被武松杀死。</p>
<p>　　这一改动，让武松保留了更多从前的性格，也推迟甚至断绝了武松的江湖之路，大大减少了江湖的血腥气。</p>
<p>　　在张青的店里，武松换上了头陀的行头，从此不再是“打虎武松”，他拥有了更值一提的伟大事迹，即使放眼江湖也是出类拔萃。</p>
<p>　　初更时分，武行者来到蜈蚣上，将要进行他第三次杀人，象征他的彻底转变。</p>
<p>　　首先他的念头就跟从前不一样，“刀却自好，到我手里不曾发市，且把这个鸟先生试刀。”武松的谨慎没有了，这次杀人既不为报仇，也无关交情，他只想“试刀”。</p>
<p>　　其次打法也不同，再无各种挑衅，也没有安排退路，拿起石头砸门，一刀杀死道童，直奔道人，大战十数合，砍下人头。</p>
<p>　　直到杀人之后，武松才问明缘由，放妇人下山，搁在从前，武松会先问后动手。</p>
<p>　　武松是江湖人了，从此以后的故事便是江湖老套：惹事生非、不打不相识、落草为寇。</p>
<p>　　那个谨慎而自制、守法守规则、满怀梦想的武松消失在蜈蚣岭上。</p>
<p>　　相比蜈蚣岭之后的快意恩仇、行走江湖，我更怀念武松从前的稚嫩与爱吹牛，甚至觉得他就生活在我身边，举起屠刀的武松，与普通人再无瓜葛，也无法得到普通人的理解。</p>
<p>　　有意思的是，金圣叹在点评中往往胜赞武二郎，将其视为“天人”，唯独对于蜈蚣岭这一段觉得索然无味，“武松蜈蚣岭一段文字，意思暗与鲁达瓦官寺一段相对，亦是初得戒刀，另与喝彩一番耳，并不复关武松之事。”</p>
<p>　　所见不同吧，我在蜈蚣岭上看到两个鲜明的武松，一个死去，一个出生。</p>
<p>　　江湖人从来就没有想象中美妙，若干年之后，武松将领悟这一点，失掉一条臂，真正出家为僧。</p>
]]></content>
      <categories>
        <category>是阅读嗷</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>blog搭建小记</title>
    <url>/2020/01/28/blog%E6%90%AD%E5%BB%BA%E5%B0%8F%E8%AE%B0/</url>
    <content><![CDATA[<p>很早很早很早就有搭自己的blog的想法，也是为了满足自己的倾诉欲，也是做一点知识输出（这方面忽视即可，<del>我基本没有知识</del></p>
<a id="more"></a>

<p>嗷，最开始是在<a href="https://www.luogu.org/blog/Venus/build-hexo-github-blog" target="_blank" rel="noopener">luogu日报</a>（<del>这篇的确很小白，但是有点呆</del>）上看见的，最吸引我的就是可以白嫖（雾</p>
<p>其实配域名啥的还是要花一点钱的，雾，也有<a href="https://certbot.eff.org/" target="_blank" rel="noopener">推荐</a>（这个听说很省事</p>
<p>后面看了蛮多相关博客的，也就明白了操作顺序其实并没有这么死板嗷</p>
<p>推荐观看：<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">官方文档</a>、<a href="https://eirunye.github.io/categories/Hexo/" target="_blank" rel="noopener">推荐1</a>、<a href="https://www.jianshu.com/p/4026acde395f" target="_blank" rel="noopener">还是推荐1嗷(简书版)</a></p>
<p>主要参考的资料来自简书以及Github还有知乎。</p>
<p>我就随便做了一下，感觉可能是个无底洞我就罢手了，反正我觉得现在这样够我玩儿了。</p>
<p>雾，好难啊，我完全写不出有意义的东西，滚去敲代码辽。</p>
<h4 id="注："><a href="#注：" class="headerlink" title="注："></a>注：</h4><ul>
<li><a href="https://www.jianshu.com/p/e17711e44e00" target="_blank" rel="noopener">添加分类及标签</a></li>
<li><a href="http://yuchen-lea.github.io/2016-01-21-use-qiniu-store-file-for-hexo/" target="_blank" rel="noopener">用七牛做图床</a></li>
</ul>
<p>​        </p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>乱七八糟</tag>
      </tags>
  </entry>
  <entry>
    <title>Git学习小记-1</title>
    <url>/2020/01/26/Git%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>其实好早就对Git感兴趣了，但是一直没有找到时间去学（其实是懒，QAQ</p>
<p>然后最近不是新冠闹得沸沸扬扬嘛，刚好春节期间也不用走亲戚串门啥的，总算是可以好好坐下来学点东西了。</p>
<a id="more"></a>

<p>嗷。挺好的。（不立Flag才不会学习</p>
<p>问<strong>狼</strong>要了一点学习资料（她主动帮我找的哈，真棒诶。</p>
<p>我自己本来在看的也就只有<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰</a>，现在多了别的可以参照了（虽然廖雪峰写的很好了</p>
<p>放一下：<a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="noopener">Git教程1</a>、<a href="http://marklodato.github.io/visual-git-guide/index-zh-cn.html" target="_blank" rel="noopener">Git教程2</a>、<a href="https://learngitbranching.js.org/" target="_blank" rel="noopener">Git教程3</a></p>
<p>还在学习ing~</p>
<p>总结一下：</p>
<p>​        廖雪峰的教程很适合系统学习。下面的评论也可以能解决很多问题。</p>
<p>​     （关于Rebase 这章写的不太清楚。。推荐观看教程2)</p>
<p>​        教程1是Git官方出的教程。</p>
<p>​        教程2更适合作为笔记来看。</p>
<p>​        教程3是模拟的小游戏qaq。</p>
<hr>
<h5 id="2-8"><a href="#2-8" class="headerlink" title="2 - 8"></a>2 - 8</h5><p>咕咕咕姑姑，鸽了好久的Git 终于又被我想起来了，今天就来个end吧（我指入门的end</p>
<p>好容易假期早起了，也得做点有意思的事情，哈哈哈</p>
<p>就把我们回访的事情挂到Github上面去⑧，正好这两天也在忙这个，差不多结束了</p>
<p>waiting~ working~</p>
<hr>
<h5 id="2-10"><a href="#2-10" class="headerlink" title="2 - 10"></a>2 - 10</h5><ul>
<li><p>创建版本库</p>
<ul>
<li><pre><code>$ mkdir learngit // 在当前目录创建名为&quot;learngit&quot; 的文件夹
$ cd learngit     // 进入&quot;learngit&quot;文件夹
$ pwd             // 显示当前目录
/Users/michael/learngit
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git init // 通过git init 命令将目录变成 Git 可以管理的仓库
Initialized empty Git repository in /Users/michael/learngit/.git/
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &gt; 初始化一个Git仓库，使用`git init`命令。</span><br><span class="line"></span><br><span class="line">- 将文件添加到版本库</span><br><span class="line"></span><br><span class="line">  - 在`learngit`目录下创建一个`readme.txt` 文件</span><br><span class="line"></span><br><span class="line">  - 这里我们的文件内容为</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
Git is a version control system.
Git is free software.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git add readme.txt // 将文件添加到暂存区
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit -m &quot;wrote a readme file&quot; // 将全部暂存区文件提交至仓库， -m &quot;xxxx&quot; 是说明
[master (root-commit) eaadf4e] wrote a readme file
 1 file changed, 2 insertions(+)
 create mode 100644 readme.txt
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">    &gt; 添加文件到Git仓库，分两步</span><br><span class="line"></span><br><span class="line">    &gt; 1. 使用命令`git add &lt;flie&gt; `，注意，可反复多次使用，添加多个文件；</span><br><span class="line"></span><br><span class="line">    &gt; 2. 使用命令`git commit -m &lt;message&gt;  `，完成。</span><br><span class="line"></span><br><span class="line">- 时光机穿梭</span><br><span class="line"></span><br><span class="line">  - 成功添加并提交了一个readme.txt文件后，我们修改readme.txt的内容</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
Git is a distributed version control system.
Git is free software.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 然后运行`git status`命令查看结果</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git status
On branch master
Changes not staged for commit:
  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)

    modified:   readme.txt

no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `git status`命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，`readme.txt`被修改过了，但还没有准备提交的修改。</span><br><span class="line"></span><br><span class="line">- 如果想要查看修改的具体内容可以使用`git diff`命令，具体如下</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git diff readme.txt 
diff --git a/readme.txt b/readme.txt
index 46d49bf..9247db6 100644
--- a/readme.txt
+++ b/readme.txt
@@ -1,2 +1,2 @@
-Git is a version control system.
+Git is a distributed version control system.
 Git is free software.
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 然后我们可以放心的提交`readme.txt`文件了</span><br><span class="line"></span><br><span class="line">- 和之前一样，第一步是执行`git add`命令</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git add readme.txt
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 在执行`git commit`命令之前，我们可以通过`git status`命令查看仓库状态</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)

    modified:   readme.txt
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- `git status`告诉我们，将要被提交的修改包括`readme.txt`，下一步，就可以放心地提交了：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git commit -m &quot;add distributed&quot;
[master e475afc] add distributed
 1 file changed, 1 insertion(+), 1 deletion(-)
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 提交后，我们再用`git status`命令看看仓库的当前状态：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
$ git status
On branch master
nothing to commit, working tree clear
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &gt; 要随时掌握工作区的状态，使用`git status`命令。</span><br><span class="line">  &gt;</span><br><span class="line">  &gt; 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。</span><br><span class="line"></span><br><span class="line">- 版本回退</span><br><span class="line"></span><br><span class="line">  - 每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为`commit`。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个`commit`恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</span><br><span class="line"></span><br><span class="line">  - 在Git中，我们用`git log`命令查看历史记录</span><br><span class="line"></span><br><span class="line">  -</span><br></pre></td></tr></table></figure>
  $ git log
  commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master)
  Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
  Date:   Fri May 18 21:06:15 2018 +0800

      append GPL

  commit e475afc93c209a690c39c13a46716e8fa000c366
  Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
  Date:   Fri May 18 21:03:36 2018 +0800

      add distributed

  commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
  Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
  Date:   Fri May 18 20:59:18 2018 +0800

      wrote a readme file
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上`--pretty=oneline`参数：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ git log --pretty=oneline
  1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -&gt; master) append GPL
  e475afc93c209a690c39c13a46716e8fa000c366 add distributed
  eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 需要友情提示的是，你看到的一大串类似`1094adb...`的是`commit id`（版本号）(以16进制表示)</span><br><span class="line"></span><br><span class="line">- 现在我们开始版本回退嗷</span><br><span class="line"></span><br><span class="line">- 在Git中，用`HEAD`表示当前版本，也就是最新的提交`1094adb...`（注意我的提交ID和你的肯定不一样），上一个版本就是`HEAD^`，上上一个版本就是`HEAD^^`，当然往上100个版本写100个`^`比较容易数不过来，所以写成`HEAD~100`。</span><br><span class="line"></span><br><span class="line">- 现在，我们要把当前版本`append GPL`回退到上一个版本`add distributed`，就可以使用`git reset`命令：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ git reset --hard HEAD^
  HEAD is now at e475afc add distributed
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 看看`readme.txt`的内容是不是版本`add distributed`：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ cat readme.txt                            //查看文件内容
  Git is a distributed version control system.
  Git is free software.
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 还可以继续回退到上一个版本`wrote a readme file`，不过且慢，然我们用`git log`再看看现在版本库的状态：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ git log
  commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -&gt; master)
  Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
  Date:   Fri May 18 21:03:36 2018 +0800

      add distributed

  commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0
  Author: Michael Liao &lt;askxuefeng@gmail.com&gt;
  Date:   Fri May 18 20:59:18 2018 +0800

      wrote a readme file
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 最新的那个版本`append GPL`已经看不到了！要是我们想回到最新版本怎么办捏</span><br><span class="line"></span><br><span class="line">- 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个`append GPL`的`commit id`是`1094adb...`，于是就可以指定回到未来的某个版本：</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ git reset --hard 1094a
  HEAD is now at 83b0afe append GPL
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">- 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</span><br><span class="line"></span><br><span class="line">- 万一命令行窗口被关掉了怎么办，我们可以使用`git reflog`命令查看命令记录</span><br><span class="line"></span><br><span class="line">-</span><br></pre></td></tr></table></figure>
  $ git reflog
  e475afc HEAD@{1}: reset: moving to HEAD^
  1094adb (HEAD -&gt; master) HEAD@{2}: commit: append GPL
  e475afc HEAD@{3}: commit: add distributed
  eaadf4e HEAD@{4}: commit (initial): wrote a readme file</code></pre><ul>
<li><p>我们可以看到，<code>append GPL</code> 的<code>commit id</code>是<code>1094adb</code></p>
<blockquote>
<p>HEAD<code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令</code>git reset –hard commit_id`。</p>
</blockquote>
<blockquote>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
</blockquote>
<blockquote>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
</blockquote>
</li>
</ul>
</li>
<li><p>工作区与暂存区</p>
</li>
<li><p>我好懒啊。。。。。先到这了。我去实操了。</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>是学习嗷</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>天气之子</title>
    <url>/2019/11/01/%E5%A4%A9%E6%B0%94%E4%B9%8B%E5%AD%90/</url>
    <content><![CDATA[<p>结束了。</p>
<a id="more"></a>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/10/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
